<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        cursor: pointer;
      }
      .process, .color-selector {
        position: absolute;
        top: 10%;
        right: 10%;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      import { scene, camera, renderer, light, controls } from "../utils/three-base.js";

      const endPoint = new THREE.Vector3(0,0,0);
      camera.position.set(0, 0, 10);
      camera.lookAt(endPoint);

      const direction = new THREE.Vector3()
      camera.getWorldDirection(direction) // 相机正视方向向量
      console.log(direction)
      /*
        手动计算
          中心位置的点坐标 - 相机位置的点坐标
          （0，0，0） - （0，0，10） => （0，0，-10）
          
          function vectorLength(x, y, z) {
            // 1求每个分量的二次幂
            const x_pow = Math.pow(x, 2);
            const y_pow = Math.pow(y, 2);
            const z_pow = Math.pow(z, 2);
            // 2求和
            const sum = x_pow + y_pow + z_pow;
            // 3开根号
            const sqrt = Math.sqrt(sum)
            const result = new THREE.Vector3(x / sqrt, y / sqrt, z / sqrt);
            return result;
          }
      */


      const cubeCamera = new THREE.Mesh(
        new THREE.SphereGeometry(0.2),
        new THREE.MeshBasicMaterial({
          color: 0xff1ff1,
          wireframe: true,
        })
      )

      // 相机位置的向量，缩放0.6得到新的向量
      const pVector = camera.position.clone().multiplyScalar(0.8);
      cubeCamera.position.copy(pVector);
      scene.add(cubeCamera);

      const geometry = new THREE.BufferGeometry().setFromPoints([pVector, endPoint]);
      const material = new THREE.LineBasicMaterial({
        color: 0xffffff,
      });
      const line = new THREE.Line(geometry, material);
      scene.add(line);


      const origin = new THREE.Vector3(0, 0, 0);
      const arrow_x_helper = createArrowHelper(origin, origin.clone().add(new THREE.Vector3(5,0,0)), 0xff0000);
      scene.add(arrow_x_helper);

      const arrow_y_helper = createArrowHelper(origin, origin.clone().add(new THREE.Vector3(0,5,0)), 0x00ff00);
      scene.add(arrow_y_helper);

      const arrow_z_helper = createArrowHelper(origin, origin.clone().add(new THREE.Vector3(0,0,5)), 0x0000ff);
      scene.add(arrow_z_helper);

      function createArrowHelper(start, end, color) {
        // 计算方向向量
        const direction = new THREE.Vector3().subVectors(end, start).normalize();
        
        // 计算箭头长度
        const length = start.distanceTo(end);
        
        // 创建箭头辅助器
        return new THREE.ArrowHelper(direction, start, length, color);;
      }
      

      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        controls.update();
      }
      requestAnimationFrame(animate);
    </script>
    </script>
  </body>
</html>
